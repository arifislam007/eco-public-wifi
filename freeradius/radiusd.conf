# FreeRADIUS Configuration File
# For Public Wi-Fi Captive Portal

prefix = /usr
exec_prefix = /usr
sysconfdir = /etc
localstatedir = /var
sbindir = ${exec_prefix}/sbin
logdir = /var/log/freeradius
raddbdir = /etc/freeradius
radacctdir = ${logdir}/radacct

# Location of config and logfiles.
confdir = ${raddbdir}
run_dir = ${localstatedir}/run/freeradius

# The logging messages for the server are appended to the
# tail of each log file as the server runs.
#
# If the server is being run by "radiusd -X", then log
# messages go to stdout.
log {
    destination = files
    file = ${logdir}/radius.log
    syslog_facility = daemon
    stripped_names = no
    auth = yes
    auth_badpass = yes
    auth_goodpass = yes
}

# The user that the server runs as.
user = freerad
group = freerad

#  A proxy server that just forwards requests to another server
#  does not need to know about clients.  The 'client.conf' file
#  can be empty (or even not exist).
#
#  The 'clients.conf' file contains configuration for RADIUS clients.
#  This is used by the 'listen' section to tell FreeRADIUS where
#  to find the list of clients.
#
#  For more information, see: man clients.conf
$INCLUDE ${confdir}/clients.conf

#  The 'listen' section tells the server what IP addresses and
#  ports to listen on.  All of the listen directives can have
#  one or more "listen" sections, or they may be omitted for
#  default values.
#
#  The server can listen on:
#  - All IP addresses on the machine:  listen { ipaddr = * }
#  - One specific IP:  listen { ipaddr = 192.168.1.1 }
#  - One specific IPv6:  listen { ipv6addr = ::1 }
#  - All IPv6 addresses:  listen { ipv6addr = * }
#
#  The port may be a number, or a text name from /etc/services
listen {
    type = auth
    ipaddr = *
    port = 0
}

listen {
    type = acct
    ipaddr = *
    port = 0
}

#  Authorization. First preprocess (hints and huntgroups files),
#  then realms, then look in the "users" file.
authorize {
    filter_username
    preprocess
    expiration
    logintime
    sql
    pap
    if (ok || updated) {
        update control {
            Auth-Type := Accept
        }
    }
}

#  Authentication.
authenticate {
    Auth-Type PAP {
        pap
    }
    Auth-Type CHAP {
        chap
    }
    Auth-Type MS-CHAP {
        mschap
    }
}

#  Pre-accounting.  Decide which accounting type to use.
preacct {
    preprocess
    acct_unique
    suffix
    files
}

#  Accounting.  Define the accounting type.
accounting {
    detail
    unix
    radutmp
    sql
    attr_filter.accounting_response
}

#  Session database, used for checking Simultaneous-Use. Either the radutmp
#  or rlm_redis module can handle this.
#  The rlm_sql module with the "pool" configuration can handle this as well.
#  See "simultaneous use" in sql.conf
session {
    radutmp
    sql
}

#  Post-Authentication
#  Once we know that the user has been authenticated, there are
#  additional steps we can take.
post-auth {
    update {
        &reply: += {
            &Reply-Message := "Welcome to Public Wi-Fi"
        }
    }
    sql
    remove_reply_message_if_eap
    Post-Auth-Type REJECT {
        attr_filter.access_reject
        eap
        remove_reply_message_if_eap
    }
}

#  Pre-proxy.  Decide which proxying to use.
pre-proxy {
}

#  Post-Proxy.  After proxying a request, you can do things like
#  log the results to a file, or update a database.
post-proxy {
    eap
}

#  When the server decides to proxy a request to a home server,
#  the proxied request is first passed through the pre-proxy
#  stage.  This stage can re-write the request, or decide to
#  cancel the proxy.
#
#  After the proxied request has been received, processed, and
#  replied to, the normal server continues processing the reply
#  in the post-proxy stage.
